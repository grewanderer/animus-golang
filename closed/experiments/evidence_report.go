package main

import (
	"bytes"
	"fmt"
	"strings"
	"time"
)

type evidenceReportInput struct {
	RunID            string
	ExecutionID      string
	ExperimentID     string
	DatasetID        string
	DatasetVersionID string
	DatasetSHA256    string
	GitRepo          string
	GitCommit        string
	GitRef           string
	ImageRef         string
	ImageDigest      string
	ExecutionHash    string
	PolicyDecisions  []policyDecisionDetail
	PolicyApprovals  []policyApprovalDetail
	GeneratedAt      time.Time
	GeneratedBy      string
}

func buildComplianceReportPDF(input evidenceReportInput) ([]byte, error) {
	lines := []string{
		"Animus DataPilot Evidence Report",
		fmt.Sprintf("Generated at: %s", input.GeneratedAt.UTC().Format(time.RFC3339)),
		fmt.Sprintf("Generated by: %s", safeValue(input.GeneratedBy)),
		"",
	}

	addLine := func(label string, value string) {
		for _, line := range wrapText(fmt.Sprintf("%s: %s", label, safeValue(value)), 90) {
			lines = append(lines, line)
		}
	}

	addLine("Run ID", input.RunID)
	addLine("Execution ID", input.ExecutionID)
	addLine("Experiment ID", input.ExperimentID)
	addLine("Dataset ID", input.DatasetID)
	addLine("Dataset Version ID", input.DatasetVersionID)
	addLine("Dataset SHA256", input.DatasetSHA256)
	addLine("Git Repo", input.GitRepo)
	addLine("Git Commit", input.GitCommit)
	addLine("Git Ref", input.GitRef)
	addLine("Image Ref", input.ImageRef)
	addLine("Image Digest", input.ImageDigest)
	addLine("Execution Hash", input.ExecutionHash)

	lines = append(lines, "")
	lines = append(lines, fmt.Sprintf("Policy decisions: %d", len(input.PolicyDecisions)))
	appendPolicyDecisionLines(&lines, input.PolicyDecisions, 5)

	lines = append(lines, "")
	lines = append(lines, fmt.Sprintf("Policy approvals: %d", len(input.PolicyApprovals)))
	appendPolicyApprovalLines(&lines, input.PolicyApprovals, 5)

	return renderSimplePDF(lines)
}

func appendPolicyDecisionLines(lines *[]string, decisions []policyDecisionDetail, limit int) {
	for i, decision := range decisions {
		if limit > 0 && i >= limit {
			*lines = append(*lines, fmt.Sprintf("... and %d more", len(decisions)-limit))
			return
		}
		descriptor := fmt.Sprintf("%s (%s)", safeValue(decision.PolicyName), safeValue(decision.Decision))
		if decision.RuleID != "" {
			descriptor = fmt.Sprintf("%s rule=%s", descriptor, safeValue(decision.RuleID))
		}
		for _, line := range wrapText(fmt.Sprintf("Decision %d: %s", i+1, descriptor), 90) {
			*lines = append(*lines, line)
		}
	}
}

func appendPolicyApprovalLines(lines *[]string, approvals []policyApprovalDetail, limit int) {
	for i, approval := range approvals {
		if limit > 0 && i >= limit {
			*lines = append(*lines, fmt.Sprintf("... and %d more", len(approvals)-limit))
			return
		}
		descriptor := fmt.Sprintf("%s (%s)", safeValue(approval.PolicyName), safeValue(approval.Status))
		if approval.RuleID != "" {
			descriptor = fmt.Sprintf("%s rule=%s", descriptor, safeValue(approval.RuleID))
		}
		for _, line := range wrapText(fmt.Sprintf("Approval %d: %s", i+1, descriptor), 90) {
			*lines = append(*lines, line)
		}
	}
}

func safeValue(value string) string {
	value = strings.TrimSpace(value)
	if value == "" {
		return "-"
	}
	return value
}

func wrapText(text string, width int) []string {
	text = strings.TrimSpace(text)
	if text == "" {
		return []string{""}
	}
	if width <= 0 || len(text) <= width {
		return []string{text}
	}
	words := strings.Fields(text)
	if len(words) == 0 {
		return []string{text}
	}
	lines := []string{}
	current := words[0]
	for _, word := range words[1:] {
		if len(current)+1+len(word) > width {
			lines = append(lines, current)
			current = word
			continue
		}
		current = current + " " + word
	}
	lines = append(lines, current)
	return lines
}

func renderSimplePDF(lines []string) ([]byte, error) {
	content := buildPDFContent(lines)

	var buf bytes.Buffer
	writeLine := func(line string) {
		buf.WriteString(line)
		buf.WriteByte('\n')
	}

	writeLine("%PDF-1.4")

	offsets := make([]int, 6)

	offsets[1] = buf.Len()
	writeLine("1 0 obj")
	writeLine("<< /Type /Catalog /Pages 2 0 R >>")
	writeLine("endobj")

	offsets[2] = buf.Len()
	writeLine("2 0 obj")
	writeLine("<< /Type /Pages /Kids [3 0 R] /Count 1 >>")
	writeLine("endobj")

	offsets[3] = buf.Len()
	writeLine("3 0 obj")
	writeLine("<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >>")
	writeLine("endobj")

	offsets[4] = buf.Len()
	writeLine("4 0 obj")
	writeLine(fmt.Sprintf("<< /Length %d >>", len(content)))
	writeLine("stream")
	buf.Write(content)
	writeLine("endstream")
	writeLine("endobj")

	offsets[5] = buf.Len()
	writeLine("5 0 obj")
	writeLine("<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>")
	writeLine("endobj")

	xrefPos := buf.Len()
	writeLine("xref")
	writeLine("0 6")
	writeLine("0000000000 65535 f ")
	for i := 1; i < len(offsets); i++ {
		writeLine(fmt.Sprintf("%010d 00000 n ", offsets[i]))
	}
	writeLine("trailer")
	writeLine("<< /Size 6 /Root 1 0 R >>")
	writeLine("startxref")
	writeLine(fmt.Sprintf("%d", xrefPos))
	writeLine("%%EOF")

	return buf.Bytes(), nil
}

func buildPDFContent(lines []string) []byte {
	var buf bytes.Buffer
	writeLine := func(line string) {
		buf.WriteString(line)
		buf.WriteByte('\n')
	}

	writeLine("BT")
	writeLine("/F1 12 Tf")
	writeLine("50 750 Td")
	for i, line := range lines {
		if i > 0 {
			writeLine("0 -14 Td")
		}
		writeLine(fmt.Sprintf("(%s) Tj", pdfEscape(sanitizePDFText(line))))
	}
	writeLine("ET")
	return buf.Bytes()
}

func sanitizePDFText(input string) string {
	var out strings.Builder
	for _, r := range input {
		if r >= 32 && r <= 126 {
			out.WriteRune(r)
		} else if r == '\t' {
			out.WriteByte(' ')
		} else {
			out.WriteByte('?')
		}
	}
	return out.String()
}

func pdfEscape(input string) string {
	replacer := strings.NewReplacer(
		"\\", "\\\\",
		"(", "\\(",
		")", "\\)",
	)
	return replacer.Replace(input)
}
